# 2023.1.8
昨天去运动了，🐏后第一次运动~  
### 今天学习了：  
## 1、多态性（polymorphism）  
多态性的实现需要向上造型（upcast）和动态绑定（dynamic binding），动态绑定是在运行时知道调用哪一个类型的函数 在某一类型中，如果  
有成员函数被virtual修饰，那么这个类的对象就会比正常的此类多一些内存占用空间，会有一个vptr（virtual pointer）指向这个类型的vtable  
vtable中会有这个类型的virtual函数，而他的子类中也会有一个vptr指向自己的vtable，vtable里有本类型的virtual函数，在动态绑定中，例如  
```
void render(Shape* p)
{
  p->render();//这里的p是多态的，它可以通过接收指针来判断调用哪一个类型的render函数
}
 ```
tips:vptr是不能通过赋值传递的  
## 2、引用作为函数参数时的细节  
当引用作为函数参数时 `void f(int&)`和`void f(const int&)`有不同，前者如过传入了不可作为左值的表达式，就会出错，因为编译器会产生一个临时变量  
这个临时变量时const int& 是不能修改的，但是int&不保证不修改，所以要用const int& 来接收参数  
如果将引用作为函数的返回值，如果作为右值，`i = f();`那么f（）会dereference，将f（）所引用的那个变量的值赋给i  
如果将引用作为左值，`f() = 3;`那么就会将f（）所引用的那个变量赋值为3  
## 3、拷贝构造(copy constructor)
拷贝构造使用已经存在的同一类的对象来构造一个新的对象，比如用对象创建对象，用对象作为函数参数，用对象作为函数返回值时都会调用到拷贝函数
如果在定义类的时候没有写拷贝构造函数，使用编译器提供的构造函数可能会出一些问题，比如有一个类里面有一个string* p 如果发生了拷贝构造，那么
两个对象中的p都会指向同一块内存空间，当析构的时候就会两次析构同一个内存空间会有错误，如果写了拷贝构造函数，new一个新空间就不会出错  
所以目前在定义一个类的时候养成习惯：
```
class  A
{
  public:
  A():{}//写出构造函数，并用列表初始化
  A(const A& cpy_A);//写出拷贝构造函数
  ~A(){};//写析构函数
};
```
:rabbit2: Click here ->[today's code on gitee](https://gitee.com/C-11nJxxs-web/study/tree/master/cpp/2023.1.8/2023.1.8)
